/*
 * Created on 8 nov 2016 ( Time 16:16:34 )
 * Generated by Telosys Tools Generator ( version 2.1.1 )
 */
package it.csi.sira.backend.metadata.utils;

import java.sql.Types;
import java.util.List;
import java.util.Map;

import org.apache.log4j.Logger;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;

public abstract class GenericDAO<T> {
	private static String className = GenericDAO.class.getSimpleName();
	private static Logger logger = Logger.getLogger("metadata");

	public NamedParameterJdbcTemplate template;

	public final static String ISNOTNULL = "ROW_ISNOT_NULL";
	public final static String ISNULL = "ROW_IS_NULL";
	public final static String TABLE_NAME = "";

	/**
	 * Constructor for a standard table (without auto-incremented column)
	 */
	public GenericDAO() {
		super();
	}

	public void setTemplate(NamedParameterJdbcTemplate template) {
		this.template = template;
	}

	protected MapSqlParameterSource getParameterValue(Map<String, Object> filter) {
		MapSqlParameterSource params = new MapSqlParameterSource();

		for (String key : filter.keySet()) {
			Object value = filter.get(key);

			if (value != null) {
				if ((value instanceof Long) || (value instanceof Integer) || (value instanceof Float) || (value instanceof Double) || (value instanceof java.math.BigDecimal)) {
					params.addValue(key, value, Types.NUMERIC);
				}
				else if (value instanceof java.util.Date) {
					params.addValue(key, value, Types.TIMESTAMP);
				}
				else if (value instanceof Boolean) {
					params.addValue(key, value, Types.BOOLEAN);
				}
				else if (value instanceof String) {
					params.addValue(key, value, Types.VARCHAR);
				}
				else {
					params.addValue(key, value);
				}
			}
			else {
				params.addValue(key, value, Types.NULL);
			}
		}

		return params;
	}

	public T findByPK(Map<String, Object> filter) {
		try {
			String query = getPrimaryKeySelect();
			MapSqlParameterSource params = getParameterValue(filter);
			return template.queryForObject(query, params, getRowMapper());
		}
		catch (EmptyResultDataAccessException e) {
			logger.debug(format(className, "findByPK", e.getMessage()));
			return null;
		}
	}

	public List<T> findAll() {
		try {
			String query = "select * from " + getTableName();
			MapSqlParameterSource params = new MapSqlParameterSource();
			return template.query(query, params, getRowMapper());
		}
		catch (EmptyResultDataAccessException e) {
			logger.debug(format(className, "findAll", e.getMessage()));
			return null;
		}
	}

	public List<T> findByCriteria(Map<String, Object> filter) {
		try {
			String query = "select * from " + getTableName() + " where 1 = 1";
			MapSqlParameterSource params = new MapSqlParameterSource();
			for (String key : filter.keySet()) {
				Object value = filter.get(key);
				if (value != null) {
					if ((value instanceof Long) || (value instanceof Integer) || (value instanceof Float) || (value instanceof Double) || (value instanceof java.math.BigDecimal)) {
						params.addValue(key, value, Types.NUMERIC);
						query += " and " + key + " = :" + key;
					}
					else if (value instanceof java.util.Date) {
						params.addValue(key, value, Types.DATE);
						query += " and " + key + " = :" + key;
					}
					else if (value instanceof Boolean) {
						params.addValue(key, value, Types.BOOLEAN);
						query += " and " + key + " = :" + key;
					}
					else if (value instanceof String) {
						if (value.equals(GenericDAO.ISNOTNULL)) {
							query += " and " + key + " is not null";
						}
						else if (value.equals(GenericDAO.ISNULL)) {
							query += " and " + key + " is null";
						}
						else {
							query += " and " + key + " = :" + key;
							params.addValue(key, value, Types.VARCHAR);
						}
					}
					else {
						query += " and " + key + " = :" + key;
						params.addValue(key, value);
					}
				}
				else {
					//query += " and " + key + " = :" + key;
					query += " and " + key + " is null";
					params.addValue(key, value, Types.NULL);
				}
			}

			return template.query(query, params, getRowMapper());
		}
		catch (EmptyResultDataAccessException e) {
			logger.debug(format(className, "findByCriteria", e.getMessage()));
			return null;
		}
	}

	public List<T> findByCriteria(MapSqlParameterSource params) {
		try {
			String query = "select * from " + getTableName() + " where 1 = 1";
			for (String key : params.getValues().keySet()) {
				Object value = params.getValues().get(key);
				if (value != null) {
					query += " and " + key + " = :" + key;
				}
				else {
					query += " and " + key + " = null";
				}
			}
			return template.query(query, params, getRowMapper());
		}
		catch (EmptyResultDataAccessException e) {
			logger.debug(format(className, "findByCriteria", e.getMessage()));
			return null;
		}
	}

	public <V> List<V> findByGenericCriteria(String query, RowMapper<V> rowMapper, Map<String, Object> params) {
		try {
			return template.query(query, getParameterValue(params), rowMapper);
		}
		catch (EmptyResultDataAccessException e) {
			logger.debug(format(className, "findByGenericCriteria", e.getMessage()));
			return null;
		}
	}

	public <V> List<V> findByGenericCriteria(String query, RowMapper<V> rowMapper, MapSqlParameterSource params) {
		try {
			return template.query(query, params, rowMapper);
		}
		catch (EmptyResultDataAccessException e) {
			logger.debug(format(className, "findByGenericCriteria", e.getMessage()));
			return null;
		}
	}

	public List<T> findByGenericCriteria(String query, MapSqlParameterSource params) {
		try {
			return template.query(query, params, getRowMapper());
		}
		catch (EmptyResultDataAccessException e) {
			logger.debug(format(className, "findByGenericCriteria", e.getMessage()));
			return null;
		}
	}

	public void insert(T bean) {
		int result = template.update(getSqlInsert(), getParameterValue(getValuesForInsert(bean)));

		if (result != 1) {
			throw new RuntimeException("Unexpected return value after INSERT : " + result + " (1 expected) ");
		}
	}

	public void update(T bean) {
		int result = template.update(getSqlUpdate(), getParameterValue(getValuesForUpdate(bean)));

		if (result != 1) {
			throw new RuntimeException("Unexpected return value after UPDATE : " + result + " (1 expected) ");
		}
	}

	public void update(String sql, Map<String, Object> param) {
		int result = template.update(sql, getParameterValue(param));

		if (result != 1) {
			throw new RuntimeException("Unexpected return value after UPDATE : " + result + " (1 expected) ");
		}
	}

	public int delete(Map<String, Object> filter) {
		MapSqlParameterSource params = getParameterValue(filter);
		int result = template.update(getSqlDelete(), params);
		return result;
	}

	public int delete(String query, Map<String, Object> params) {
		int result = template.update(query, params);
		return result;
	}

	public int delete(String query, MapSqlParameterSource params) {
		int result = template.update(query, params);
		return result;
	}

	public boolean exist(Map<String, Object> params) {
		long count = template.queryForObject(getSqlCount(), params, Long.class);
		return count > 0;
	}

	//-----------------------------------------------------------------------------------------
	/**
	 * Formats an array of objects in a String ready for printing
	 * 
	 * @param objects
	 * @return
	 */
	public String toString(Object[] objects) {
		if (objects != null) {
			StringBuilder sb = new StringBuilder();
			sb.append("[");
			int i = 0;
			for (Object o : objects) {
				if (i > 0) {
					sb.append("|");
				}
				sb.append(o.toString());
				i++;
			}
			sb.append("]");
			return sb.toString();
		}
		else {
			return "null";
		}
	}

	public String toString(Map<String, Object> objects) {
		if (objects != null) {
			StringBuilder sb = new StringBuilder();
			sb.append("[");
			int i = 0;
			for (Object o : objects.keySet()) {
				if (i > 0) {
					sb.append("|");
				}
				sb.append(o.toString());
				i++;
			}
			sb.append("]");
			return sb.toString();
		}
		else {
			return "null";
		}
	}

	/**
	 * Returns the SQL SELECT REQUEST to be used to retrieve the bean data from
	 * the database
	 * 
	 * @return
	 */
	public abstract String getPrimaryKeySelect();

	/**
	 * Returns the SQL SELECT REQUEST to be used to retrieve the bean data from
	 * the database
	 * 
	 * @return
	 */
	public abstract String getSqlSelect();

	/**
	 * Returns the SQL INSERT REQUEST to be used to insert the bean in the
	 * database
	 * 
	 * @return
	 */
	public abstract String getSqlInsert();

	/**
	 * Returns the SQL UPDATE REQUEST to be used to update the bean in the
	 * database
	 * 
	 * @return
	 */
	public abstract String getSqlUpdate();

	/**
	 * Returns the SQL DELETE REQUEST to be used to delete the bean from the
	 * database
	 * 
	 * @return
	 */
	public abstract String getSqlDelete();

	public abstract Map<String, Object> getValuesForDelete(T bean);

	/**
	 * Returns the SQL COUNT REQUEST to be used to check if the bean exists in the
	 * database
	 * 
	 * @return
	 */
	public abstract String getSqlCount();

	/**
	 * Returns the values to be used in the SQL INSERT PreparedStatement
	 * 
	 * @param bean
	 * @return
	 */
	public abstract Map<String, Object> getValuesForInsert(T bean);

	/**
	 * Returns the values to be used in the SQL UPDATE PreparedStatement
	 * 
	 * @param bean
	 * @return
	 */
	public abstract Map<String, Object> getValuesForUpdate(T bean);

	/**
	 * Returns a RowMapper for a new bean instance
	 * 
	 * @return
	 */
	public abstract RowMapper<T> getRowMapper();

	public abstract String getTableName();

	private String format(String className, String methodName, String msg) {
		StringBuffer sb = new StringBuffer();
		sb.append("[").append(className).append("::").append(methodName).append("] ").append(msg);
		return sb.toString();
	}
}
